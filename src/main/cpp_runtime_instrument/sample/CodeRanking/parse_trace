#! /usr/bin/env python3
import subprocess
import argparse


class TraceParser:
    def __init__(self, executable_name, trace_filename):
        self.executable_name = executable_name
        self.trace_filename = trace_filename
        self.addr_call_dict = dict()
        self.name_call_dict = dict()
        self.names = dict()

    def get_name(self, addr: int, show_file: bool = False) -> str:
        hex_addr_str = f"{addr:0>12x}"
        name_getter_result = subprocess.run(["addr2line",
                                             hex_addr_str,
                                             "-e",
                                             self.executable_name,
                                             "-fpCs"],
                                            stdout=subprocess.PIPE).stdout.decode("utf-8")[:-1]
        if show_file:
            return name_getter_result
        return name_getter_result.split(" at ")[0]

    def _build_util_dicts(self, show_file: bool = False):
        with open(self.trace_filename, "r") as trace_file:
            base_address = int(trace_file.readline(), 16)

            call_line = trace_file.readline()
            while call_line:
                callable_address = int(call_line[2:14], 16) - base_address
                caller_address = int(call_line[17:], 16) - base_address

                if callable_address not in self.names:
                    self.names[callable_address] = self.get_name(
                        callable_address, show_file)
                if caller_address not in self.names:
                    self.names[caller_address] = self.get_name(
                        caller_address, show_file)

                if self.names[callable_address] != "?? ??:0" and self.names[caller_address] != "?? ??:0":
                    if callable_address not in self.addr_call_dict:
                        self.addr_call_dict[callable_address] = dict()
                    if caller_address not in self.addr_call_dict[callable_address]:
                        self.addr_call_dict[callable_address][caller_address] = 0
                    self.addr_call_dict[callable_address][caller_address] += 1

                call_line = trace_file.readline()

    def build_name_call_dict(self, show_file: bool = False):
        self._build_util_dicts(show_file)
        for callable_address in self.addr_call_dict:
            callable_name = self.names[callable_address]
            self.name_call_dict[callable_name] = dict()
            for caller_address in self.addr_call_dict[callable_address]:
                caller_name = self.names[caller_address]
                if caller_name not in self.name_call_dict[callable_name]:
                    self.name_call_dict[callable_name][caller_name] = 0
                self.name_call_dict[callable_name][caller_name] += self.addr_call_dict[callable_address][caller_address]

    def print_name_call_dict(self):
        for callable_name in self.name_call_dict:
            print(callable_name)
            for caller_name in self.name_call_dict[callable_name]:
                print(
                    '\t' +
                    f"{self.name_call_dict[callable_name][caller_name]} call(s) from {caller_name}")
            print()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Parse trace created by instrumented run")
    parser.add_argument(
        "-e",
        "--executable",
        help="Executable filename",
        required=True)
    parser.add_argument(
        "-t",
        "--trace",
        help="Trace filename",
        required=True)
    parser.add_argument(
        '-f',
        action="store_true",
        help="whether show functions location (-g compiler flag required)")
    args = parser.parse_args()
    var_data = vars(args)

    TP = TraceParser(var_data['executable'], var_data['trace'])
    TP.build_name_call_dict(var_data['f'])
    TP.print_name_call_dict()
