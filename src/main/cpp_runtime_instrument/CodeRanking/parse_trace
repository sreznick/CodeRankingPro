#! /usr/bin/env python3
import subprocess
import argparse
import json


class TraceParser:
    def __init__(self, executable_name, trace_filename):
        self.executable_name = executable_name
        self.trace_filename = trace_filename
        self.call_dict = dict()
        self.addr_to_name_map = dict()
        self.name_ids = dict()
        self.name_list = []
        self.last_id = 0

    def get_name(self, addr: int, show_file: bool = False) -> str:
        hex_addr_str = f"{addr:0>12x}"
        name_getter_result = subprocess.run(["addr2line",
                                             hex_addr_str,
                                             "-e",
                                             self.executable_name,
                                             "-fpCs"],
                                            stdout=subprocess.PIPE).stdout.decode("utf-8")[:-1]
        if show_file:
            return name_getter_result
        return name_getter_result.split(" at ")[0]

    def build_util_data(self, show_file: bool = False):
        with open(self.trace_filename, "r") as trace_file:
            base_address = int(trace_file.readline(), 16)

            call_line = trace_file.readline()
            while call_line:
                callable_address = int(call_line[2:14], 16) - base_address
                caller_address = int(call_line[17:], 16) - base_address

                if callable_address not in self.addr_to_name_map:
                    self.addr_to_name_map[callable_address] = self.get_name(
                        callable_address, show_file)
                if caller_address not in self.addr_to_name_map:
                    self.addr_to_name_map[caller_address] = self.get_name(
                        caller_address, show_file)

                callable_name = self.addr_to_name_map[callable_address]
                caller_name = self.addr_to_name_map[caller_address]

                if callable_name != "?? ??:0" and caller_name != "?? ??:0":
                    if callable_name not in self.name_ids:
                        self.last_id += 1
                        self.name_ids[callable_name] = self.last_id
                        self.name_list.append(callable_name)

                    if caller_name not in self.name_ids:
                        self.last_id += 1
                        self.name_ids[caller_name] = self.last_id
                        self.name_list.append(caller_name)

                    if callable_name not in self.call_dict:
                        self.call_dict[callable_name] = dict()
                    if caller_name not in self.call_dict[callable_name]:
                        self.call_dict[callable_name][caller_name] = 0
                    self.call_dict[callable_name][caller_name] += 1

                call_line = trace_file.readline()

    def print_name_call_dict(self):
        for callable_name in self.call_dict:
            print(callable_name)
            for caller_name in self.call_dict[callable_name]:
                print(
                    '\t' +
                    f"{self.call_dict[callable_name][caller_name]} call(s) from {caller_name}")
            print()

    def save_json(self, filename: str):
        final_list = []
        for function_name in self.name_list:
            function_data = dict()
            function_data["id"] = self.name_ids[function_name]
            function_data["name"] = function_name
            function_data["links"] = []
            if function_name in self.call_dict:
                for caller_name in self.call_dict[function_name]:
                    function_data["links"].append(
                        {"id": self.name_ids[caller_name], "count": self.call_dict[function_name][caller_name]})
            final_list.append(function_data)

        with open(filename, "w") as output_file:
            output_file.write(
                json.dumps(final_list, indent='\t')
            )
        


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Parse trace created by instrumented run")
    parser.add_argument(
        "-e",
        "--executable",
        help="Executable filename",
        required=True)
    parser.add_argument(
        "-t",
        "--trace",
        help="Trace filename",
        required=True)
    parser.add_argument(
        "-j",
        "--json-dest",
        help="Path to file to save graph in json format",
        default=None)
    parser.add_argument(
        '-f',
        action="store_true",
        help="whether show functions location (-g compiler flag required)")
    args = parser.parse_args()
    var_data = vars(args)

    TP = TraceParser(var_data['executable'], var_data['trace'])
    TP.build_util_data()

    if var_data['json_dest'] is None:
        TP.print_name_call_dict()
    else:
        TP.save_json(var_data['json_dest'])
